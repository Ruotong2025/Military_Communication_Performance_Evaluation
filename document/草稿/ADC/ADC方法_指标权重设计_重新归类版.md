# ADC方法指标权重设计方案（重新归类版）

## 一、ADC定义与指标映射

### 1.1 ADC三要素定义

根据你的重新归类，ADC三要素的定义为：

- **A (Availability - 可用性)**：系统在**开始执行任务时**所处状态的指标
- **D (Dependability - 可信性)**：系统**执行任务过程中**所处状态的指标  
- **C (Capability - 能力)**：系统**执行任务结果**的指标

### 1.2 完整指标映射表

| ADC要素 | 指标数量 | 建议权重 | 说明 |
|---------|---------|---------|------|
| **A (可用性)** | 4个 | 30% | 任务开始前的就绪状态 |
| **D (可信性)** | 10个 | 40% | 任务执行过程的可靠性 |
| **C (能力)** | 7个 | 30% | 任务执行的结果质量 |
| **总计** | 21个 | 100% | |

---

## 二、可用性（A）- 任务开始时的就绪状态

### 2.1 指标清单（4个）

| 序号 | 指标代码 | 指标名称 | 方向 | 重要性 | 说明 |
|------|---------|---------|------|--------|------|
| A1 | NC_avg_connectivity_rate | 平均连通率 | ↑ | ⭐⭐⭐⭐⭐ | 网络是否连通 |
| A2 | NC_avg_network_setup_duration_ms | 平均组网时长 | ↓ | ⭐⭐⭐⭐ | 组网速度 |
| A3 | HO_operation_success_rate | 操作成功率 | ↑ | ⭐⭐⭐⭐ | 操作员能否成功操作 |
| A4 | HO_avg_operator_reaction_time_ms | 操作员反应时间 | ↓ | ⭐⭐⭐ | 操作员响应速度 |

**核心含义**：
- 网络能否快速建立？（连通率、组网时长）
- 操作员能否快速准备？（操作成功率、反应时间）

### 2.2 权重设计方案

#### 方案1：AHP主观权重

**判断矩阵**（4×4）：
```
        A1   A2   A3   A4
A1(连通率)  [1,   3,   2,   4]
A2(组网时长)[1/3, 1,   1/2, 2]
A3(操作成功率)[1/2, 2,   1,   3]
A4(反应时间)[1/4, 1/2, 1/3, 1]
```

**计算结果**：
```python
AHP权重:
  A1 - 平均连通率:         0.4500 (45.00%)  # 最重要
  A2 - 平均组网时长:       0.2000 (20.00%)
  A3 - 操作成功率:         0.2500 (25.00%)
  A4 - 操作员反应时间:     0.1000 (10.00%)
```

#### 方案2：两层权重（推荐）⭐

**第一层：维度权重**
```
组网能力(NC) vs 人为操作(HO)

判断矩阵:
        NC   HO
NC      [1,   3]    # 组网能力比人为操作重要3倍
HO      [1/3, 1]

权重:
  NC - 组网能力:   0.75 (75%)
  HO - 人为操作:   0.25 (25%)
```

**第二层：指标权重**
```
组网能力内部（2个指标）:
  A1 - 平均连通率:         0.70 (70% of NC)
  A2 - 平均组网时长:       0.30 (30% of NC)

人为操作内部（2个指标）:
  A3 - 操作成功率:         0.70 (70% of HO)
  A4 - 操作员反应时间:     0.30 (30% of HO)
```

**最终权重**：
```python
最终权重:
  A1 - 平均连通率:         0.75 × 0.70 = 0.5250 (52.50%)
  A2 - 平均组网时长:       0.75 × 0.30 = 0.2250 (22.50%)
  A3 - 操作成功率:         0.25 × 0.70 = 0.1750 (17.50%)
  A4 - 操作员反应时间:     0.25 × 0.30 = 0.0750 (7.50%)
```

---

## 三、可信性（D）- 任务执行过程的可靠性

### 3.1 指标清单（10个）

| 序号 | 指标代码 | 指标名称 | 方向 | 重要性 | 说明 |
|------|---------|---------|------|--------|------|
| D1 | EF_avg_ber | 平均误码率 | ↓ | ⭐⭐⭐⭐⭐ | 传输质量 |
| D2 | EF_avg_plr | 平均丢包率 | ↓ | ⭐⭐⭐⭐⭐ | 传输可靠性 |
| D3 | SC_interception_resistance | 抗拦截能力 | ↑ | ⭐⭐⭐⭐ | 安全性 |
| D4 | SC_detection_probability | 被侦察概率 | ↓ | ⭐⭐⭐⭐ | 隐蔽性 |
| D5 | SC_key_compromise_frequency | 密钥泄露频率 | ↓ | ⭐⭐⭐ | 密钥安全 |
| D6 | AJ_avg_sinr | 平均信干噪比 | ↑ | ⭐⭐⭐⭐ | 抗干扰 |
| D7 | AJ_avg_jamming_margin | 平均抗干扰余量 | ↑ | ⭐⭐⭐ | 干扰容限 |
| D8 | RL_communication_availability_rate | 通信可用性 | ↑ | ⭐⭐⭐⭐⭐ | 持续可用 |
| D9 | RL_crash_rate | 崩溃比例 | ↓ | ⭐⭐⭐⭐ | 稳定性 |
| D10 | RL_recovery_duration_ms | 恢复时长 | ↓ | ⭐⭐⭐ | 恢复能力 |

**核心含义**：
- 传输过程是否可靠？（误码率、丢包率）
- 通信过程是否安全？（抗拦截、被侦察、密钥）
- 抗干扰能力如何？（信干噪比、抗干扰余量）
- 系统是否稳定？（可用性、崩溃率、恢复时长）

### 3.2 权重设计方案（两层权重）⭐

**第一层：维度权重**
```
有效性(EF) vs 安全性(SC) vs 抗干扰(AJ) vs 可靠性(RL)

判断矩阵（4×4）:
        EF   SC   AJ   RL
EF      [1,   1,   2,   1/2]
SC      [1,   1,   2,   1/2]
AJ      [1/2, 1/2, 1,   1/3]
RL      [2,   2,   3,   1]

权重:
  EF - 有效性:     0.25 (25%)
  SC - 安全性:     0.25 (25%)
  AJ - 抗干扰性:   0.15 (15%)
  RL - 可靠性:     0.35 (35%)  # 最重要
```

**第二层：指标权重**

**有效性内部（2个指标）**：
```python
  D1 - 平均误码率:   0.55 (55% of EF)
  D2 - 平均丢包率:   0.45 (45% of EF)
```

**安全性内部（3个指标）**：
```python
  D3 - 抗拦截能力:         0.50 (50% of SC)
  D4 - 被侦察概率:         0.35 (35% of SC)
  D5 - 密钥泄露频率:       0.15 (15% of SC)
```

**抗干扰性内部（2个指标）**：
```python
  D6 - 平均信干噪比:       0.70 (70% of AJ)
  D7 - 平均抗干扰余量:     0.30 (30% of AJ)
```

**可靠性内部（3个指标）**：
```python
  D8 - 通信可用性:         0.50 (50% of RL)
  D9 - 崩溃比例:           0.35 (35% of RL)
  D10 - 恢复时长:          0.15 (15% of RL)
```

**最终权重**：
```python
最终权重:
  D1 - 平均误码率:         0.25 × 0.55 = 0.1375 (13.75%)
  D2 - 平均丢包率:         0.25 × 0.45 = 0.1125 (11.25%)
  D3 - 抗拦截能力:         0.25 × 0.50 = 0.1250 (12.50%)
  D4 - 被侦察概率:         0.25 × 0.35 = 0.0875 (8.75%)
  D5 - 密钥泄露频率:       0.25 × 0.15 = 0.0375 (3.75%)
  D6 - 平均信干噪比:       0.15 × 0.70 = 0.1050 (10.50%)
  D7 - 平均抗干扰余量:     0.15 × 0.30 = 0.0450 (4.50%)
  D8 - 通信可用性:         0.35 × 0.50 = 0.1750 (17.50%)
  D9 - 崩溃比例:           0.35 × 0.35 = 0.1225 (12.25%)
  D10 - 恢复时长:          0.35 × 0.15 = 0.0525 (5.25%)
```

---

## 四、能力（C）- 任务执行结果

### 4.1 指标清单（7个）

| 序号 | 指标代码 | 指标名称 | 方向 | 重要性 | 说明 |
|------|---------|---------|------|--------|------|
| C1 | PO_effective_throughput | 有效吞吐量 | ↑ | ⭐⭐⭐⭐⭐ | 数据传输量 |
| C2 | PO_spectral_efficiency | 频谱效率 | ↑ | ⭐⭐⭐⭐ | 频谱利用率 |
| C3 | RS_avg_transmission_delay_ms | 平均传输时延 | ↓ | ⭐⭐⭐⭐ | 实时性 |
| C4 | RS_avg_call_setup_duration_ms | 平均呼叫建立时长 | ↓ | ⭐⭐⭐ | 响应速度 |
| C5 | EF_task_success_rate | 任务成功率 | ↑ | ⭐⭐⭐⭐⭐ | 任务完成度 |
| C6 | EF_avg_communication_distance | 平均通信距离 | ↑ | ⭐⭐⭐⭐ | 覆盖范围 |
| C7 | RL_communication_success_rate | 通信成功率 | ↑ | ⭐⭐⭐⭐⭐ | 通信建立成功 |

**核心含义**：
- 数据传输效果如何？（吞吐量、频谱效率）
- 响应速度如何？（传输时延、呼叫建立时长）
- 任务完成情况如何？（任务成功率、通信成功率、通信距离）

### 4.2 权重设计方案（两层权重）⭐

**第一层：维度权重**
```
处理能力(PO) vs 响应能力(RS) vs 有效性(EF) vs 可靠性(RL)

判断矩阵（4×4）:
        PO   RS   EF   RL
PO      [1,   2,   1/2, 1/2]
RS      [1/2, 1,   1/3, 1/3]
EF      [2,   3,   1,   1]
RL      [2,   3,   1,   1]

权重:
  PO - 处理能力:   0.20 (20%)
  RS - 响应能力:   0.12 (12%)
  EF - 有效性:     0.34 (34%)
  RL - 可靠性:     0.34 (34%)
```

**第二层：指标权重**

**处理能力内部（2个指标）**：
```python
  C1 - 有效吞吐量:   0.60 (60% of PO)
  C2 - 频谱效率:     0.40 (40% of PO)
```

**响应能力内部（2个指标）**：
```python
  C3 - 平均传输时延:       0.65 (65% of RS)
  C4 - 平均呼叫建立时长:   0.35 (35% of RS)
```

**有效性内部（2个指标）**：
```python
  C5 - 任务成功率:         0.60 (60% of EF)
  C6 - 平均通信距离:       0.40 (40% of EF)
```

**可靠性内部（1个指标）**：
```python
  C7 - 通信成功率:         1.00 (100% of RL)
```

**最终权重**：
```python
最终权重:
  C1 - 有效吞吐量:         0.20 × 0.60 = 0.1200 (12.00%)
  C2 - 频谱效率:           0.20 × 0.40 = 0.0800 (8.00%)
  C3 - 平均传输时延:       0.12 × 0.65 = 0.0780 (7.80%)
  C4 - 平均呼叫建立时长:   0.12 × 0.35 = 0.0420 (4.20%)
  C5 - 任务成功率:         0.34 × 0.60 = 0.2040 (20.40%)
  C6 - 平均通信距离:       0.34 × 0.40 = 0.1360 (13.60%)
  C7 - 通信成功率:         0.34 × 1.00 = 0.3400 (34.00%)
```

---

## 五、完整权重配置总结

### 5.1 标准配置（推荐使用）

```python
# ========== ADC三要素权重 ==========
ADC_WEIGHTS = {
    'A': 0.30,  # 可用性 30%（任务开始时）
    'D': 0.40,  # 可信性 40%（任务执行中）
    'C': 0.30   # 能力 30%（任务结果）
}

# ========== 可用性（A）指标权重 ==========
A_WEIGHTS = {
    'NC_avg_connectivity_rate': 0.5250,              # 52.50%
    'NC_avg_network_setup_duration_ms': 0.2250,      # 22.50%
    'HO_operation_success_rate': 0.1750,             # 17.50%
    'HO_avg_operator_reaction_time_ms': 0.0750       # 7.50%
}

# ========== 可信性（D）指标权重 ==========
D_WEIGHTS = {
    'EF_avg_ber': 0.1375,                            # 13.75%
    'EF_avg_plr': 0.1125,                            # 11.25%
    'SC_interception_resistance': 0.1250,            # 12.50%
    'SC_detection_probability': 0.0875,              # 8.75%
    'SC_key_compromise_frequency': 0.0375,           # 3.75%
    'AJ_avg_sinr': 0.1050,                           # 10.50%
    'AJ_avg_jamming_margin': 0.0450,                 # 4.50%
    'RL_communication_availability_rate': 0.1750,    # 17.50%
    'RL_crash_rate': 0.1225,                         # 12.25%
    'RL_recovery_duration_ms': 0.0525                # 5.25%
}

# ========== 能力（C）指标权重 ==========
C_WEIGHTS = {
    'PO_effective_throughput': 0.1200,               # 12.00%
    'PO_spectral_efficiency': 0.0800,                # 8.00%
    'RS_avg_transmission_delay_ms': 0.0780,          # 7.80%
    'RS_avg_call_setup_duration_ms': 0.0420,         # 4.20%
    'EF_task_success_rate': 0.2040,                  # 20.40%
    'EF_avg_communication_distance': 0.1360,         # 13.60%
    'RL_communication_success_rate': 0.3400          # 34.00%
}
```

### 5.2 权重验证

```python
# 验证权重和为1
assert abs(sum(A_WEIGHTS.values()) - 1.0) < 0.0001  # ✓
assert abs(sum(D_WEIGHTS.values()) - 1.0) < 0.0001  # ✓
assert abs(sum(C_WEIGHTS.values()) - 1.0) < 0.0001  # ✓

# 验证ADC权重和为1
assert abs(sum(ADC_WEIGHTS.values()) - 1.0) < 0.0001  # ✓
```

---

## 六、不同场景的权重调整

### 6.1 战时通信场景

```python
# ADC权重调整
ADC_WEIGHTS_WARTIME = {
    'A': 0.35,  # 可用性↑（快速就绪）
    'D': 0.45,  # 可信性↑（过程可靠）
    'C': 0.20   # 能力↓（结果次要）
}

# D内部调整（强调安全性和可靠性）
D_WEIGHTS_WARTIME = {
    'EF': 0.20,  # 有效性↓
    'SC': 0.35,  # 安全性↑↑
    'AJ': 0.15,  # 抗干扰→
    'RL': 0.30   # 可靠性↓
}
```

### 6.2 应急通信场景

```python
# ADC权重调整
ADC_WEIGHTS_EMERGENCY = {
    'A': 0.45,  # 可用性↑↑（快速组网）
    'D': 0.35,  # 可信性↓
    'C': 0.20   # 能力↓
}

# A内部调整（强调组网速度）
A_WEIGHTS_EMERGENCY = {
    'NC': 0.85,  # 组网能力↑↑
    'HO': 0.15   # 人为操作↓
}
```

### 6.3 日常通信场景

```python
# ADC权重调整（均衡）
ADC_WEIGHTS_DAILY = {
    'A': 0.25,  # 可用性↓
    'D': 0.35,  # 可信性↓
    'C': 0.40   # 能力↑↑（强调性能）
}
```

---

## 七、关键差异说明

### 7.1 与之前方案的对比

| 对比项 | 之前方案 | 新方案 | 说明 |
|--------|---------|--------|------|
| **A的定义** | 可靠性+组网 | 组网+人为操作 | 更符合"任务开始时"的定义 |
| **D的定义** | 安全+抗干扰+有效性 | 有效+安全+抗干扰+可靠 | 增加了可靠性维度 |
| **C的定义** | 处理+响应+人为 | 处理+响应+有效+可靠 | 强调任务结果 |
| **指标数量** | A:6, D:9, C:6 | A:4, D:10, C:7 | 重新分配 |

### 7.2 新方案的优势

1. **更符合ADC原始定义**
   - A：任务开始前的准备状态
   - D：任务执行过程的可靠性
   - C：任务执行的最终结果

2. **逻辑更清晰**
   - 时间维度明确：开始→过程→结果
   - 因果关系清晰：准备→执行→产出

3. **便于理解和解释**
   - 向上级汇报时更容易说明
   - 符合军事作战流程

---

## 八、实施建议

### 8.1 计算流程

```python
# 步骤1：归一化所有指标到0-1区间
normalized_data = normalize(raw_data)

# 步骤2：计算A、D、C三要素
A = sum(normalized_data[indicator] * A_WEIGHTS[indicator] 
        for indicator in A_WEIGHTS.keys())

D = sum(normalized_data[indicator] * D_WEIGHTS[indicator] 
        for indicator in D_WEIGHTS.keys())

C = sum(normalized_data[indicator] * C_WEIGHTS[indicator] 
        for indicator in C_WEIGHTS.keys())

# 步骤3：计算综合效能
E = A * D * C

# 步骤4：效能等级
if E >= 0.90:
    grade = "优秀"
elif E >= 0.80:
    grade = "良好"
elif E >= 0.70:
    grade = "中等"
elif E >= 0.60:
    grade = "及格"
else:
    grade = "较差"
```

### 8.2 短板分析

```python
# 识别短板
adc_scores = {'A': A, 'D': D, 'C': C}
min_score = min(adc_scores.values())
bottleneck = [k for k, v in adc_scores.items() if v == min_score][0]

print(f"短板要素: {bottleneck}")
print(f"改进建议: 重点提升{bottleneck}相关指标")
```

---

**总结**：

这个新方案更符合ADC的原始定义，将指标按照**时间维度**（任务开始→执行→结果）进行分类，逻辑更清晰，便于理解和实施。

需要我创建完整的Python实现脚本吗？
