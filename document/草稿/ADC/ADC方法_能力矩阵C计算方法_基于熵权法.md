# ADC方法 - 能力矩阵C的计算方法（基于熵权法）

## 参考文献
许鹏飞, 张伟华, 马润年. 基于熵权的改进ADC法通信基础网作战效能评估算法[J]. 火力与指挥控制, 2013, 38(1): 64-68.

---

## 一、能力矩阵C的核心思想

### 1.1 传统ADC方法的问题

**论文指出**：
> "在ADC模型中，能力向量C是系统效能集中的体现，也是评估系统效能的关键。但在模型中能力向量C应包含哪些能力项，ADC方法没有给出一个统一的、规范的标准。"

**传统方法的不足**：
- ❌ 没有统一的指标体系
- ❌ 能力向量C的计算过于主观
- ❌ 缺乏科学的权重确定方法

### 1.2 改进方案

**论文提出**：
> "在建立通信基础网作战能力指标体系的前提下，运用熵权法求解能力向量C。"

**核心改进**：
1. ✅ 构建完整的能力指标体系
2. ✅ 使用熵权法确定客观权重
3. ✅ 结合主观权重（AHP法）
4. ✅ 计算不同工作状态下的能力值

---

## 二、能力矩阵C的计算步骤

### 步骤1：构建能力指标体系

**论文图3：通信基础网作战能力指标体系**

```
通信基础网作战能力
├── 通信信息处理能力 (W₁)
│   ├── 信息处理速度 (W₁₁)
│   ├── 信息处理容量 (W₁₂)
│   └── 信息处理准确性 (W₁₃)
├── 通信指挥控制能力 (W₂)
│   ├── 指挥响应时间 (W₂₁)
│   ├── 指挥决策能力 (W₂₂)
│   └── 指挥协同能力 (W₂₃)
├── 通信传输能力 (W₃)
│   ├── 传输速率 (W₃₁)
│   ├── 传输容量 (W₃₂)
│   └── 传输可靠性 (W₃₃)
├── 通信覆盖能力 (W₄)
│   ├── 覆盖范围 (W₄₁)
│   ├── 覆盖密度 (W₄₂)
│   └── 覆盖质量 (W₄₃)
├── 通信抗干扰能力 (W₅)
│   ├── 抗电磁干扰 (W₅₁)
│   ├── 抗物理破坏 (W₅₂)
│   └── 抗网络攻击 (W₅₃)
└── 通信生存能力 (W₆)
    ├── 冗余备份能力 (W₆₁)
    ├── 快速恢复能力 (W₆₂)
    └── 自适应能力 (W₆₃)
```

**对应你的通信系统**：
```
军事通信系统作战能力
├── 网络组网能力
│   ├── 组网速度
│   ├── 网络连通率
│   └── 网络稳定性
├── 信号传输能力
│   ├── 信干噪比(SINR)
│   ├── 误码率(BER)
│   └── 丢包率(PLR)
├── 通信质量能力
│   ├── 传输时延
│   ├── 吞吐量
│   └── 呼叫建立时长
├── 抗干扰能力
│   ├── 干扰容限
│   ├── 频谱利用率
│   └── 自适应调制
├── 操作保障能力
│   ├── 操作成功率
│   ├── 操作员反应时间
│   └── 操作错误率
└── 系统可靠性
    ├── 通信成功率
    ├── 网络崩溃率
    └── 中断时长
```

### 步骤2：熵权法确定客观权重

**理论基础**：
- 熵值越小，信息量越大，权重越大
- 熵值越大，信息量越小，权重越小

**计算公式**（论文式5）：

```python
# 1. 构建评价指标决策矩阵X
X = [[x₁₁, x₁₂, ..., x₁ₙ],  # 专家1的评分
     [x₂₁, x₂₂, ..., x₂ₙ],  # 专家2的评分
     ...
     [xₘ₁, xₘ₂, ..., xₘₙ]]  # 专家m的评分

# 其中：
# m = 专家数量
# n = 评价指标数量
# xᵢⱼ = 专家i对指标j的评分

# 2. 标准化处理（归一化）
dᵢⱼ = xᵢⱼ / Σxᵢⱼ  # 每个元素除以该列的和

# 3. 计算指标j的熵值
dⱼ = Σdᵢⱼ  # 第j列的和
E = -Σ(dᵢⱼ/dⱼ × ln(dᵢⱼ/dⱼ))  # 条件熵

# 4. 归一化熵值
eⱼ = E / ln(m)  # 评价决策重要性熵

# 5. 计算熵权
Eₑ = Σeⱼ  # 所有指标的熵值之和
W'ⱼ = (1 - eⱼ) / (n - Eₑ)  # 指标j的熵权

# 约束：0 ≤ W'ⱼ ≤ 1，且 ΣW'ⱼ = 1
```

### 步骤3：组合权重（主观+客观）

**论文式6**：

```python
# 主观权重（AHP法）
αₖ = AHP法计算的权重

# 客观权重（熵权法）
W'ₖ = 熵权法计算的权重

# 综合权重
Wₖ = (αₖ × W'ₖ) / Σ(αₖ × W'ₖ)
```

**论文表3示例**：

| 一级指标 | 主观权重(AHP) | 熵权 | 综合权重 |
|---------|--------------|------|---------|
| 信息处理能力 | 0.30 | 0.2525 | 0.4172 |
| 指挥控制能力 | 0.15 | 0.1775 | 0.1464 |
| 传输能力 | 0.12 | 0.1545 | 0.1018 |
| 覆盖能力 | 0.14 | 0.1655 | 0.1277 |
| 抗干扰能力 | 0.13 | 0.1050 | 0.0754 |
| 生存能力 | 0.16 | 0.1495 | 0.1315 |

### 步骤4：计算各工作状态下的能力值

**论文式7**：

```python
# 在第k种工作状态下的能力值
cₖ = Σᵢ₌₁ᵐ Wᵢ × Σⱼ₌₁ⁿ Wᵢⱼ × Fᵏᵢⱼ

其中：
m = 一级指标数量
n = 二级指标数量
Wᵢ = 一级指标i的综合权重
Wᵢⱼ = 二级指标ij的综合权重
Fᵏᵢⱼ = 在第k种工作状态下，指标ij的标准化专家评分
```

**物理意义**：
- 不同工作状态下，系统的能力不同
- 状态1（全部正常）：能力最强
- 状态8（全部故障）：能力为0

### 步骤5：构建能力向量C

**论文式8**：

```python
C = [c₁, c₂, c₃, c₄, c₅, c₆, c₇, c₈]ᵀ

其中：
c₁ = 全部正常状态的能力值
c₂ = 子系统③故障状态的能力值
c₃ = 子系统④故障状态的能力值
c₄ = 子系统⑤故障状态的能力值
c₅ = 子系统③④故障状态的能力值
c₆ = 子系统③⑤故障状态的能力值
c₇ = 子系统④⑤故障状态的能力值
c₈ = 全部故障状态的能力值（通常为0）
```

---

## 三、完整Python实现

```python
import numpy as np
import pandas as pd

class CapabilityMatrixCalculator:
    """
    能力矩阵C计算器（基于熵权法）
    
    参考：许鹏飞等. 基于熵权的改进ADC法通信基础网作战效能评估算法[J].
         火力与指挥控制, 2013, 38(1): 64-68.
    """
    
    def __init__(self, indicator_system):
        """
        参数:
            indicator_system: 指标体系字典
                {
                    '一级指标1': ['二级指标1', '二级指标2', ...],
                    '一级指标2': ['二级指标1', '二级指标2', ...],
                    ...
                }
        """
        self.indicator_system = indicator_system
        self.level1_count = len(indicator_system)
        self.level2_counts = {k: len(v) for k, v in indicator_system.items()}
    
    def calculate_entropy_weight(self, expert_scores):
        """
        计算熵权（论文式5）
        
        参数:
            expert_scores: 专家评分矩阵 (m×n)
                         m = 专家数量
                         n = 指标数量
        
        返回:
            entropy_weights: 熵权向量 (1×n)
        """
        m, n = expert_scores.shape
        
        # 步骤1：标准化（归一化）
        D = expert_scores / expert_scores.sum(axis=0)
        
        # 步骤2：计算熵值
        entropy = np.zeros(n)
        for j in range(n):
            dj = D[:, j].sum()
            # 避免log(0)
            pij = D[:, j] / dj
            pij = pij[pij > 0]  # 只保留大于0的值
            entropy[j] = -np.sum(pij * np.log(pij))
        
        # 步骤3：归一化熵值
        ej = entropy / np.log(m)
        
        # 步骤4：计算熵权
        Ee = ej.sum()
        entropy_weights = (1 - ej) / (n - Ee)
        
        return entropy_weights
    
    def calculate_combined_weight(self, ahp_weights, entropy_weights):
        """
        计算组合权重（论文式6）
        
        参数:
            ahp_weights: AHP主观权重 (1×n)
            entropy_weights: 熵权客观权重 (1×n)
        
        返回:
            combined_weights: 组合权重 (1×n)
        """
        # 组合权重
        product = ahp_weights * entropy_weights
        combined_weights = product / product.sum()
        
        return combined_weights
    
    def calculate_capability_value(self, level1_weights, level2_weights, 
                                   expert_scores_normalized):
        """
        计算某一工作状态下的能力值（论文式7）
        
        参数:
            level1_weights: 一级指标权重字典 {指标名: 权重}
            level2_weights: 二级指标权重字典 {(一级指标, 二级指标): 权重}
            expert_scores_normalized: 标准化后的专家评分字典 
                                     {(一级指标, 二级指标): 评分}
        
        返回:
            capability: 能力值 (标量)
        """
        capability = 0
        
        for level1_name, level1_weight in level1_weights.items():
            level2_sum = 0
            
            # 获取该一级指标下的所有二级指标
            level2_indicators = self.indicator_system[level1_name]
            
            for level2_name in level2_indicators:
                key = (level1_name, level2_name)
                level2_weight = level2_weights.get(key, 0)
                score = expert_scores_normalized.get(key, 0)
                
                level2_sum += level2_weight * score
            
            capability += level1_weight * level2_sum
        
        return capability
    
    def build_capability_matrix(self, state_scores, level1_weights, level2_weights):
        """
        构建能力矩阵C（论文式8）
        
        参数:
            state_scores: 各工作状态下的专家评分
                        {
                            'state1': {(一级指标, 二级指标): 评分},
                            'state2': {(一级指标, 二级指标): 评分},
                            ...
                        }
            level1_weights: 一级指标权重
            level2_weights: 二级指标权重
        
        返回:
            C: 能力向量 (n×1)
        """
        num_states = len(state_scores)
        C = np.zeros(num_states)
        
        for i, (state_name, scores) in enumerate(state_scores.items()):
            C[i] = self.calculate_capability_value(
                level1_weights, 
                level2_weights, 
                scores
            )
        
        return C.reshape(-1, 1)


# 使用示例
if __name__ == "__main__":
    # 步骤1：定义指标体系
    indicator_system = {
        '网络组网能力': ['组网速度', '网络连通率', '网络稳定性'],
        '信号传输能力': ['信干噪比', '误码率', '丢包率'],
        '通信质量能力': ['传输时延', '吞吐量', '呼叫建立时长'],
        '抗干扰能力': ['干扰容限', '频谱利用率', '自适应调制'],
        '操作保障能力': ['操作成功率', '反应时间', '操作错误率'],
        '系统可靠性': ['通信成功率', '网络崩溃率', '中断时长']
    }
    
    # 创建计算器
    calculator = CapabilityMatrixCalculator(indicator_system)
    
    # 步骤2：专家评分（示例数据）
    # 假设5个专家对6个一级指标评分
    expert_scores_level1 = np.array([
        [0.85, 0.80, 0.75, 0.70, 0.65, 0.75],  # 专家1
        [0.90, 0.85, 0.80, 0.75, 0.70, 0.80],  # 专家2
        [0.80, 0.75, 0.70, 0.65, 0.60, 0.70],  # 专家3
        [0.85, 0.80, 0.75, 0.70, 0.65, 0.75],  # 专家4
        [0.88, 0.82, 0.78, 0.72, 0.68, 0.78]   # 专家5
    ])
    
    # 步骤3：计算熵权
    entropy_weights = calculator.calculate_entropy_weight(expert_scores_level1)
    print("熵权:", entropy_weights)
    
    # 步骤4：AHP主观权重（示例）
    ahp_weights = np.array([0.30, 0.15, 0.12, 0.14, 0.13, 0.16])
    
    # 步骤5：计算组合权重
    combined_weights = calculator.calculate_combined_weight(ahp_weights, entropy_weights)
    print("组合权重:", combined_weights)
    
    # 步骤6：构建一级指标权重字典
    level1_names = list(indicator_system.keys())
    level1_weights = {name: weight for name, weight in zip(level1_names, combined_weights)}
    
    # 步骤7：计算二级指标权重（简化：假设均匀分布）
    level2_weights = {}
    for level1_name, level2_list in indicator_system.items():
        level1_weight = level1_weights[level1_name]
        level2_weight = level1_weight / len(level2_list)
        for level2_name in level2_list:
            level2_weights[(level1_name, level2_name)] = level2_weight
    
    # 步骤8：定义各工作状态下的专家评分（示例）
    state_scores = {
        'state1': {  # 全部正常
            ('网络组网能力', '组网速度'): 0.95,
            ('网络组网能力', '网络连通率'): 0.98,
            ('网络组网能力', '网络稳定性'): 0.96,
            # ... 其他指标
        },
        'state2': {  # 部分故障
            ('网络组网能力', '组网速度'): 0.70,
            ('网络组网能力', '网络连通率'): 0.75,
            ('网络组网能力', '网络稳定性'): 0.72,
            # ... 其他指标
        },
        # ... 其他状态
    }
    
    # 步骤9：构建能力矩阵C
    C = calculator.build_capability_matrix(state_scores, level1_weights, level2_weights)
    print("\n能力矩阵C:")
    print(C)
```

---

## 四、论文实例分析

### 4.1 论文数据

**表3：一级指标权重分析**

| 一级指标 | 主观权重 | 熵权 | 综合权重 |
|---------|---------|------|---------|
| W₁ | 0.30 | 0.2525 | 0.4172 |
| W₂ | 0.15 | 0.1775 | 0.1464 |
| W₃ | 0.12 | 0.1545 | 0.1018 |
| W₄ | 0.14 | 0.1655 | 0.1277 |
| W₅ | 0.13 | 0.1050 | 0.0754 |
| W₆ | 0.16 | 0.1495 | 0.1315 |

**二级指标权重**（部分）：
- W₁₁ = 0.5227, W₁₂ = 0.2116, W₁₃ = 0.2657
- ...
- W₆₁ = 0.3188, W₆₂ = 0.4819, W₆₃ = 0.1993

### 4.2 能力值计算

**状态1（全部正常）**：
```python
# 专家评分
F¹₁₁ = 0.85, F¹₁₂ = 0.75, F¹₁₃ = 0.80
...
F¹₆₁ = 0.75, F¹₆₂ = 0.65, F¹₆₃ = 0.70

# 计算能力值（论文式7）
c₁ = W₁×(W₁₁×F¹₁₁ + W₁₂×F¹₁₂ + W₁₃×F¹₁₃) + 
     W₂×(W₂₁×F¹₂₁ + W₂₂×F¹₂₂ + W₂₃×F¹₂₃) +
     ...
     W₆×(W₆₁×F¹₆₁ + W₆₂×F¹₆₂ + W₆₃×F¹₆₃)
   = 0.9475
```

**其他状态**：
```python
c₂ = 0.6134  # 子系统③故障
c₃ = 0.7675  # 子系统④故障
c₄ = 0.7464  # 子系统⑤故障
c₅ = 0.2454  # 子系统③④故障
c₆ = 0.2718  # 子系统③⑤故障
c₇ = 0.6523  # 子系统④⑤故障
c₈ = 0       # 全部故障
```

**能力矩阵C**：
```python
C = [0.9457, 0.6134, 0.7675, 0.7464, 0.2454, 0.2718, 0.6523, 0]ᵀ
```

### 4.3 最终效能计算

```python
E = A × D × C = 0.6853
```

---

## 五、与舰载通信装备论文的对比

### 5.1 两种方法的区别

| 对比项 | 舰载通信装备论文 | 通信基础网论文（熵权法） |
|-------|----------------|---------------------|
| C的维度 | 2×5矩阵 | 8×1向量 |
| C的来源 | 模糊评判 | 熵权法+指标体系 |
| 状态数量 | 2种（正常/故障） | 8种（多设备组合） |
| 权重方法 | 未明确 | AHP+熵权组合 |
| 指标体系 | 未明确 | 完整的两级指标体系 |

### 5.2 如何选择

**使用舰载通信装备方法**（2×5矩阵）：
- ✅ 系统简单，只有2种状态
- ✅ 已有模糊评判结果
- ✅ 需要快速评估

**使用通信基础网方法**（8×1向量）：
- ✅ 系统复杂，多个子系统
- ✅ 需要详细的指标体系
- ✅ 需要科学的权重确定
- ✅ 需要区分不同故障状态

---

## 六、推荐方案：混合方法

### 6.1 结合两种方法的优点

```python
# 方案1：简化版（2×5矩阵）
C = [[b₁, b₂, b₃, b₄, b₅],  # 正常状态
     [0,  0,  0,  0,  0 ]]  # 故障状态

# 其中b₁~b₅通过熵权法计算得到

# 方案2：完整版（8×1向量）
C = [c₁, c₂, c₃, c₄, c₅, c₆, c₇, c₈]ᵀ

# 每个cᵢ都通过熵权法+指标体系计算
```

### 6.2 实际应用建议

**对于你的军事通信系统**：

1. **构建指标体系**（参考通信基础网论文）
2. **使用熵权法确定权重**（客观+科学）
3. **选择合适的矩阵形式**：
   - 如果只关心整体效能：使用2×5矩阵
   - 如果需要详细分析：使用8×1向量

---

## 七、总结

### 7.1 能力矩阵C的计算核心

```
C的计算 = 指标体系 + 权重确定 + 专家评分

其中：
- 指标体系：定义"能力"包含哪些方面
- 权重确定：使用熵权法（客观）+ AHP法（主观）
- 专家评分：针对不同工作状态打分
```

### 7.2 关键公式

```python
# 熵权
W'ⱼ = (1 - eⱼ) / (n - Eₑ)

# 组合权重
Wₖ = (αₖ × W'ₖ) / Σ(αₖ × W'ₖ)

# 能力值
cₖ = Σᵢ Wᵢ × Σⱼ Wᵢⱼ × Fᵏᵢⱼ

# 能力矩阵
C = [c₁, c₂, ..., cₙ]ᵀ
```

### 7.3 优势

1. **科学性**：熵权法提供客观权重
2. **完整性**：指标体系覆盖全面
3. **灵活性**：可适应不同工作状态
4. **可操作性**：有明确的计算步骤

---

**参考文献**：
1. 许鹏飞, 张伟华, 马润年. 基于熵权的改进ADC法通信基础网作战效能评估算法[J]. 火力与指挥控制, 2013, 38(1): 64-68.
2. 魏玉人等. 基于ADC的舰载通信装备FAHP效能评估方法研究[J]. 舰船电子工程, 2020, 第12期: 110.
