# 军事通信效能评估 - ADC方法设计方案

## 一、ADC方法在通信效能评估中的应用框架

### 1.1 核心公式

```
通信系统效能 E = A × D × C
```

其中：
- **A (Availability)** - 可用性：系统在需要时能够正常工作的概率
- **D (Dependability)** - 可信性：系统在规定条件下完成任务的概率  
- **C (Capability)** - 能力：系统完成任务的质量和效果

### 1.2 与现有指标体系的映射

根据你的脚本中的8个维度21个指标，我们将其映射到ADC三要素：

```
ADC三要素映射：
├── A (可用性) ← 可靠性(RL) + 组网能力(NC)
├── D (可信性) ← 安全性(SC) + 抗干扰性(AJ) + 有效性(EF)
└── C (能力) ← 处理能力(PO) + 响应能力(RS) + 人为操作(HO)
```

---

## 二、ADC三要素详细设计

### 2.1 可用性（A）- Availability

**定义**：通信系统在任意时刻处于可工作状态的概率

**包含维度**：
- **可靠性（RL）**：系统稳定运行的基础
- **组网能力（NC）**：快速建立通信网络的能力

#### 指标映射

| 指标代码 | 指标名称 | 在ADC中的作用 | 权重建议 |
|---------|---------|--------------|---------|
| **RL_communication_availability_rate** | 通信可用性 | 核心指标：直接反映系统可用度 | 30% |
| **RL_communication_success_rate** | 通信成功率 | 核心指标：反映通信建立成功率 | 25% |
| **RL_crash_rate** | 崩溃比例 | 关键指标：系统稳定性（逆向） | 20% |
| **RL_recovery_duration_ms** | 恢复时长 | 辅助指标：故障恢复能力（逆向） | 10% |
| **NC_avg_connectivity_rate** | 平均连通率 | 辅助指标：网络连通性 | 10% |
| **NC_avg_network_setup_duration_ms** | 平均组网时长 | 辅助指标：快速组网能力（逆向） | 5% |

#### 计算公式

**方法一：加权平均法**
```python
A = Σ(wi × normalized_score_i)

其中：
- wi：第i个指标的权重
- normalized_score_i：第i个指标的归一化得分（0-1）
```

**方法二：MTBF/MTTR模型（理论计算）**
```python
A = MTBF / (MTBF + MTTR)

其中：
- MTBF = 总运行时间 / 崩溃次数
- MTTR = 总恢复时长 / 崩溃次数
```

**推荐使用方法一**，因为：
- 包含更多维度的信息
- 不仅考虑故障，还考虑成功率和连通性
- 与现有评估体系一致

#### 计算示例

```python
# 假设某测试批次的归一化得分（0-100分）
scores = {
    'RL_communication_availability_rate': 95.0,  # 可用性95%
    'RL_communication_success_rate': 92.0,       # 成功率92%
    'RL_crash_rate': 85.0,                       # 崩溃率低（归一化后）
    'RL_recovery_duration_ms': 70.0,             # 恢复时长中等
    'NC_avg_connectivity_rate': 88.0,            # 连通率88%
    'NC_avg_network_setup_duration_ms': 75.0     # 组网时长中等
}

weights = {
    'RL_communication_availability_rate': 0.30,
    'RL_communication_success_rate': 0.25,
    'RL_crash_rate': 0.20,
    'RL_recovery_duration_ms': 0.10,
    'NC_avg_connectivity_rate': 0.10,
    'NC_avg_network_setup_duration_ms': 0.05
}

# 转换为0-1区间
A = sum(scores[k]/100 * weights[k] for k in scores.keys())
A = 0.95*0.30 + 0.92*0.25 + 0.85*0.20 + 0.70*0.10 + 0.88*0.10 + 0.75*0.05
A = 0.285 + 0.230 + 0.170 + 0.070 + 0.088 + 0.038
A = 0.881 = 88.1%
```

**解读**：该系统有88.1%的时间处于可用状态

---

### 2.2 可信性（D）- Dependability

**定义**：系统在规定条件下成功完成通信任务的概率

**包含维度**：
- **安全性（SC）**：抗侦察、抗拦截、密钥安全
- **抗干扰性（AJ）**：在干扰环境下保持通信
- **有效性（EF）**：通信质量和任务完成度

#### 指标映射

| 指标代码 | 指标名称 | 在ADC中的作用 | 权重建议 |
|---------|---------|--------------|---------|
| **EF_task_success_rate** | 任务成功率 | 核心指标：直接反映任务完成度 | 25% |
| **EF_avg_ber** | 平均误码率 | 核心指标：通信质量（逆向） | 15% |
| **EF_avg_plr** | 平均丢包率 | 核心指标：传输可靠性（逆向） | 15% |
| **SC_interception_resistance** | 抗拦截能力 | 重要指标：安全性保障 | 15% |
| **AJ_avg_sinr** | 平均信干噪比 | 重要指标：抗干扰能力 | 12% |
| **SC_detection_probability** | 被侦察概率 | 辅助指标：隐蔽性（逆向） | 8% |
| **SC_key_compromise_frequency** | 密钥泄露频率 | 辅助指标：密钥安全（逆向） | 5% |
| **AJ_avg_jamming_margin** | 平均抗干扰余量 | 辅助指标：干扰容限 | 5% |

#### 计算公式

**标准ADC模型**
```python
D = R(t) × M × S

其中：
- R(t)：可靠性（任务时间内无故障概率）
- M：维修性（故障后恢复能力）
- S：保障性（后勤支援满足度）
```

**通信系统改进模型**
```python
D = Quality × Security × Anti-Jamming

其中：
- Quality = f(误码率, 丢包率, 任务成功率)
- Security = f(抗拦截, 被侦察概率, 密钥安全)
- Anti-Jamming = f(信干噪比, 抗干扰余量)
```

**推荐使用加权平均法**（与可用性一致）：
```python
D = Σ(wi × normalized_score_i)
```

#### 计算示例

```python
scores = {
    'EF_task_success_rate': 90.0,
    'EF_avg_ber': 88.0,              # 误码率低（归一化后）
    'EF_avg_plr': 85.0,              # 丢包率低（归一化后）
    'SC_interception_resistance': 92.0,
    'AJ_avg_sinr': 87.0,
    'SC_detection_probability': 80.0, # 被侦察概率低（归一化后）
    'SC_key_compromise_frequency': 95.0, # 泄露频率低（归一化后）
    'AJ_avg_jamming_margin': 83.0
}

weights = {
    'EF_task_success_rate': 0.25,
    'EF_avg_ber': 0.15,
    'EF_avg_plr': 0.15,
    'SC_interception_resistance': 0.15,
    'AJ_avg_sinr': 0.12,
    'SC_detection_probability': 0.08,
    'SC_key_compromise_frequency': 0.05,
    'AJ_avg_jamming_margin': 0.05
}

D = sum(scores[k]/100 * weights[k] for k in scores.keys())
D = 0.90*0.25 + 0.88*0.15 + 0.85*0.15 + 0.92*0.15 + 0.87*0.12 + 0.80*0.08 + 0.95*0.05 + 0.83*0.05
D = 0.225 + 0.132 + 0.128 + 0.138 + 0.104 + 0.064 + 0.048 + 0.042
D = 0.881 = 88.1%
```

**解读**：该系统有88.1%的概率成功完成通信任务

---

### 2.3 能力（C）- Capability

**定义**：系统完成通信任务的质量和效果

**包含维度**：
- **处理能力（PO）**：数据处理和传输能力
- **响应能力（RS）**：快速响应和建立通信
- **人为操作（HO）**：操作员的操作效率

#### 指标映射

| 指标代码 | 指标名称 | 在ADC中的作用 | 权重建议 |
|---------|---------|--------------|---------|
| **PO_effective_throughput** | 有效吞吐量 | 核心指标：数据传输能力 | 25% |
| **PO_spectral_efficiency** | 频谱效率 | 核心指标：频谱利用率 | 20% |
| **EF_avg_communication_distance** | 平均通信距离 | 重要指标：覆盖范围 | 20% |
| **RS_avg_transmission_delay_ms** | 平均传输时延 | 重要指标：实时性（逆向） | 15% |
| **RS_avg_call_setup_duration_ms** | 平均呼叫建立时长 | 辅助指标：响应速度（逆向） | 10% |
| **HO_operation_success_rate** | 操作成功率 | 辅助指标：人机协同 | 7% |
| **HO_avg_operator_reaction_time_ms** | 操作员反应时间 | 辅助指标：操作效率（逆向） | 3% |

#### 计算公式

**性能指标加权法**
```python
C = Σ(wi × normalized_score_i)
```

**效能比法**（可选）
```python
C = 实际效能 / 理想效能

其中：
- 实际效能 = 实际吞吐量 × 实际距离 / 实际时延
- 理想效能 = 理论吞吐量 × 最大距离 / 最小时延
```

#### 计算示例

```python
scores = {
    'PO_effective_throughput': 85.0,
    'PO_spectral_efficiency': 82.0,
    'EF_avg_communication_distance': 88.0,
    'RS_avg_transmission_delay_ms': 90.0,  # 时延低（归一化后）
    'RS_avg_call_setup_duration_ms': 87.0, # 建立快（归一化后）
    'HO_operation_success_rate': 92.0,
    'HO_avg_operator_reaction_time_ms': 85.0 # 反应快（归一化后）
}

weights = {
    'PO_effective_throughput': 0.25,
    'PO_spectral_efficiency': 0.20,
    'EF_avg_communication_distance': 0.20,
    'RS_avg_transmission_delay_ms': 0.15,
    'RS_avg_call_setup_duration_ms': 0.10,
    'HO_operation_success_rate': 0.07,
    'HO_avg_operator_reaction_time_ms': 0.03
}

C = sum(scores[k]/100 * weights[k] for k in scores.keys())
C = 0.85*0.25 + 0.82*0.20 + 0.88*0.20 + 0.90*0.15 + 0.87*0.10 + 0.92*0.07 + 0.85*0.03
C = 0.213 + 0.164 + 0.176 + 0.135 + 0.087 + 0.064 + 0.026
C = 0.865 = 86.5%
```

**解读**：该系统的通信能力达到理想水平的86.5%

---

## 三、ADC综合效能计算

### 3.1 标准ADC模型

```python
E = A × D × C
E = 0.881 × 0.881 × 0.865
E = 0.671 = 67.1%
```

**解读**：该通信系统的综合效能为67.1%

### 3.2 效能等级划分

| 效能值 | 等级 | 说明 |
|--------|------|------|
| E ≥ 0.90 | 优秀 | 系统性能卓越，可用于关键任务 |
| 0.80 ≤ E < 0.90 | 良好 | 系统性能良好，适合常规作战 |
| 0.70 ≤ E < 0.80 | 中等 | 系统性能中等，需要改进 |
| 0.60 ≤ E < 0.70 | 及格 | 系统勉强可用，存在明显短板 |
| E < 0.60 | 较差 | 系统不可靠，不建议使用 |

### 3.3 短板分析

ADC模型的乘积特性体现了"短板效应"：
- 如果A、D、C中任何一项很低，综合效能都会很低
- 需要均衡发展，不能有明显短板

**示例分析**：
```
场景1：均衡发展
A = 0.85, D = 0.85, C = 0.85
E = 0.85³ = 0.614 (61.4%)

场景2：有短板
A = 0.95, D = 0.95, C = 0.50  # 能力短板
E = 0.95 × 0.95 × 0.50 = 0.451 (45.1%)

结论：即使可用性和可信性都很高，但能力不足会严重拉低综合效能
```

---

## 四、ADC方法的优势

### 4.1 与现有方法对比

| 对比项 | 现有方法（AHP+熵权） | ADC方法 |
|--------|---------------------|---------|
| 评估维度 | 8个维度平行评估 | 3个核心要素层次评估 |
| 权重分配 | 主观+客观组合 | 基于系统特性 |
| 短板识别 | 不明显 | 非常明显（乘积模型） |
| 可解释性 | 较好 | 优秀（军方标准） |
| 计算复杂度 | 中等 | 简单 |
| 适用场景 | 详细评估 | 快速决策 |

### 4.2 互补性

**建议：两种方法结合使用**

1. **ADC方法**：宏观评估，快速识别短板
   - 用于高层决策
   - 快速对比多个系统
   - 识别关键问题

2. **AHP+熵权法**：详细评估，精确量化
   - 用于深入分析
   - 指导具体改进
   - 科研论证

---

## 五、实施建议

### 5.1 评估流程

```
步骤1：数据收集
  ↓
步骤2：指标归一化（0-100分）
  ↓
步骤3：计算A、D、C三要素
  ↓
步骤4：计算综合效能E = A × D × C
  ↓
步骤5：短板分析和改进建议
```

### 5.2 权重调整建议

**可用性（A）权重调整**：
- 军事通信：可靠性权重↑，组网能力权重↓
- 应急通信：组网能力权重↑，恢复时长权重↑
- 日常通信：可用性权重↓，能力权重↑

**可信性（D）权重调整**：
- 战时环境：安全性权重↑，抗干扰权重↑
- 和平时期：有效性权重↑，安全性权重↓
- 电磁复杂环境：抗干扰权重↑↑

**能力（C）权重调整**：
- 数据传输任务：吞吐量权重↑
- 实时通信任务：时延权重↑
- 远程通信任务：距离权重↑

### 5.3 注意事项

1. **数据质量**
   - 确保原始数据准确可靠
   - 归一化方法要统一
   - 处理异常值和缺失值

2. **权重设置**
   - 根据实际场景调整权重
   - 可以使用AHP确定权重
   - 进行敏感性分析

3. **结果解释**
   - 不要过度依赖单一数值
   - 重点关注短板要素
   - 结合实际情况分析

---

## 六、与现有脚本的集成

详见配套的Python实现脚本：
`Military_Communication_ADC_Evaluation.py`

该脚本包含：
- 完整的ADC计算流程
- 与现有数据库的集成
- 可视化分析（雷达图、对比图）
- 短板分析和改进建议
- 与AHP+熵权法的对比

---

**总结**：

ADC方法为军事通信效能评估提供了一个清晰、直观的框架：
- **可用性（A）**：系统能不能用？
- **可信性（D）**：系统可不可靠？
- **能力（C）**：系统强不强？

通过乘积模型，ADC方法能够有效识别系统短板，为改进提供明确方向。建议与现有的AHP+熵权法结合使用，形成"宏观+微观"的完整评估体系。
