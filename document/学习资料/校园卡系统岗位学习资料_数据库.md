# 数据库知识学习资料

## 一、数据库基础理论

### 1.1 关系型数据库基本概念

#### 数据库三级模式结构
- **外模式（用户视图）**：用户看到的数据视图
- **模式（逻辑结构）**：数据库的整体逻辑结构
- **内模式（物理结构）**：数据的物理存储方式

#### 关系模型
- **关系（表）**：二维表格，由行和列组成
- **元组（行）**：表中的一行数据
- **属性（列）**：表中的一列
- **主键（Primary Key）**：唯一标识每行数据
- **外键（Foreign Key）**：建立表间关系

#### 数据库范式
- **第一范式（1NF）**：属性不可分割
- **第二范式（2NF）**：消除部分依赖
- **第三范式（3NF）**：消除传递依赖
- **BCNF范式**：消除主属性对码的部分和传递依赖

**示例：校园卡数据库设计**
```sql
-- 学生信息表（符合3NF）
CREATE TABLE students (
    student_id VARCHAR(20) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    gender CHAR(1),
    department VARCHAR(50),
    enrollment_year INT
);

-- 校园卡信息表
CREATE TABLE campus_cards (
    card_id VARCHAR(20) PRIMARY KEY,
    student_id VARCHAR(20),
    card_number VARCHAR(30) UNIQUE,
    balance DECIMAL(10,2) DEFAULT 0,
    status VARCHAR(10) DEFAULT 'active',
    issue_date DATE,
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);

-- 消费记录表
CREATE TABLE transactions (
    transaction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    card_id VARCHAR(20),
    merchant_id VARCHAR(20),
    amount DECIMAL(10,2),
    transaction_time DATETIME,
    transaction_type VARCHAR(20),
    FOREIGN KEY (card_id) REFERENCES campus_cards(card_id)
);
```

### 1.2 事务管理

#### ACID特性
1. **原子性（Atomicity）**：事务是不可分割的最小单位
2. **一致性（Consistency）**：事务前后数据保持一致
3. **隔离性（Isolation）**：并发事务互不干扰
4. **持久性（Durability）**：事务提交后永久保存

#### 事务隔离级别
| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| READ UNCOMMITTED | 可能 | 可能 | 可能 |
| READ COMMITTED | 不可能 | 可能 | 可能 |
| REPEATABLE READ | 不可能 | 不可能 | 可能 |
| SERIALIZABLE | 不可能 | 不可能 | 不可能 |

**事务示例：校园卡充值**
```sql
START TRANSACTION;

-- 更新卡余额
UPDATE campus_cards 
SET balance = balance + 100 
WHERE card_id = 'C001';

-- 记录充值流水
INSERT INTO transactions (card_id, amount, transaction_type, transaction_time)
VALUES ('C001', 100, 'recharge', NOW());

COMMIT;
```

### 1.3 索引原理

#### 索引类型
- **B+树索引**：最常用，适合范围查询
- **哈希索引**：等值查询快，不支持范围查询
- **全文索引**：用于文本搜索
- **空间索引**：用于地理位置数据

#### 索引优化原则
1. 在WHERE、ORDER BY、JOIN字段上建索引
2. 选择性高的列适合建索引
3. 避免在小表上建索引
4. 复合索引遵循最左前缀原则
5. 避免索引列上使用函数

**索引示例**
```sql
-- 单列索引
CREATE INDEX idx_student_id ON campus_cards(student_id);

-- 复合索引
CREATE INDEX idx_card_time ON transactions(card_id, transaction_time);

-- 唯一索引
CREATE UNIQUE INDEX idx_card_number ON campus_cards(card_number);

-- 查看索引使用情况
EXPLAIN SELECT * FROM transactions 
WHERE card_id = 'C001' AND transaction_time > '2024-01-01';
```

---

## 二、SQL语言精讲

### 2.1 数据查询（SELECT）

#### 基础查询
```sql
-- 查询所有学生信息
SELECT * FROM students;

-- 查询指定列
SELECT student_id, name, department FROM students;

-- 条件查询
SELECT * FROM students WHERE department = '计算机学院';

-- 模糊查询
SELECT * FROM students WHERE name LIKE '张%';

-- 范围查询
SELECT * FROM campus_cards WHERE balance BETWEEN 50 AND 200;

-- 空值查询
SELECT * FROM students WHERE email IS NULL;
```

#### 排序与分页
```sql
-- 排序
SELECT * FROM campus_cards ORDER BY balance DESC;

-- 多列排序
SELECT * FROM students ORDER BY department ASC, enrollment_year DESC;

-- 分页查询（MySQL）
SELECT * FROM transactions LIMIT 10 OFFSET 20;

-- 分页查询（SQL Server）
SELECT * FROM transactions 
ORDER BY transaction_id 
OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;
```

#### 聚合函数
```sql
-- 统计总数
SELECT COUNT(*) FROM students;

-- 求和
SELECT SUM(amount) FROM transactions WHERE transaction_type = 'consume';

-- 平均值
SELECT AVG(balance) FROM campus_cards;

-- 最大最小值
SELECT MAX(balance), MIN(balance) FROM campus_cards;

-- 分组统计
SELECT department, COUNT(*) as student_count
FROM students
GROUP BY department;

-- 分组过滤
SELECT card_id, SUM(amount) as total_consume
FROM transactions
WHERE transaction_type = 'consume'
GROUP BY card_id
HAVING SUM(amount) > 1000;
```

### 2.2 多表连接

#### 内连接（INNER JOIN）
```sql
-- 查询学生及其校园卡信息
SELECT s.student_id, s.name, c.card_number, c.balance
FROM students s
INNER JOIN campus_cards c ON s.student_id = c.student_id;
```

#### 左连接（LEFT JOIN）
```sql
-- 查询所有学生，包括未办卡的学生
SELECT s.student_id, s.name, c.card_number, c.balance
FROM students s
LEFT JOIN campus_cards c ON s.student_id = c.student_id;
```

#### 右连接（RIGHT JOIN）
```sql
-- 查询所有校园卡，包括未关联学生的卡
SELECT s.name, c.card_number, c.balance
FROM students s
RIGHT JOIN campus_cards c ON s.student_id = c.student_id;
```

#### 多表连接
```sql
-- 查询学生消费记录
SELECT s.name, c.card_number, t.amount, t.transaction_time
FROM students s
INNER JOIN campus_cards c ON s.student_id = c.student_id
INNER JOIN transactions t ON c.card_id = t.card_id
WHERE t.transaction_type = 'consume'
ORDER BY t.transaction_time DESC;
```

### 2.3 子查询

```sql
-- 查询余额高于平均值的卡
SELECT * FROM campus_cards
WHERE balance > (SELECT AVG(balance) FROM campus_cards);

-- IN子查询
SELECT * FROM students
WHERE student_id IN (
    SELECT student_id FROM campus_cards WHERE balance > 100
);

-- EXISTS子查询
SELECT * FROM students s
WHERE EXISTS (
    SELECT 1 FROM campus_cards c 
    WHERE c.student_id = s.student_id AND c.status = 'active'
);
```

### 2.4 数据操作（DML）

#### 插入数据
```sql
-- 单行插入
INSERT INTO students (student_id, name, gender, department)
VALUES ('2024001', '张三', '男', '计算机学院');

-- 多行插入
INSERT INTO students VALUES
('2024002', '李四', '女', '数学学院', 2024),
('2024003', '王五', '男', '物理学院', 2024);

-- 从查询结果插入
INSERT INTO backup_transactions
SELECT * FROM transactions WHERE transaction_time < '2023-01-01';
```

#### 更新数据
```sql
-- 更新单条记录
UPDATE campus_cards SET balance = 200 WHERE card_id = 'C001';

-- 批量更新
UPDATE campus_cards SET status = 'expired' 
WHERE issue_date < DATE_SUB(NOW(), INTERVAL 4 YEAR);

-- 关联更新
UPDATE campus_cards c
INNER JOIN students s ON c.student_id = s.student_id
SET c.status = 'graduated'
WHERE s.enrollment_year < 2020;
```

#### 删除数据
```sql
-- 删除指定记录
DELETE FROM transactions WHERE transaction_time < '2020-01-01';

-- 删除所有记录（保留表结构）
DELETE FROM temp_table;

-- 清空表（更快，不记录日志）
TRUNCATE TABLE temp_table;
```

---

## 三、数据库运维实操

### 3.1 用户权限管理

```sql
-- 创建用户
CREATE USER 'card_admin'@'localhost' IDENTIFIED BY 'password123';

-- 授予权限
GRANT SELECT, INSERT, UPDATE ON campus_card_db.* TO 'card_admin'@'localhost';

-- 授予所有权限
GRANT ALL PRIVILEGES ON campus_card_db.* TO 'card_admin'@'localhost';

-- 查看用户权限
SHOW GRANTS FOR 'card_admin'@'localhost';

-- 撤销权限
REVOKE INSERT, UPDATE ON campus_card_db.* FROM 'card_admin'@'localhost';

-- 删除用户
DROP USER 'card_admin'@'localhost';

-- 刷新权限
FLUSH PRIVILEGES;
```

### 3.2 备份与恢复

#### MySQL备份
```bash
# 完全备份（单个数据库）
mysqldump -u root -p campus_card_db > backup_20240222.sql

# 备份所有数据库
mysqldump -u root -p --all-databases > all_backup.sql

# 备份指定表
mysqldump -u root -p campus_card_db students campus_cards > tables_backup.sql

# 只备份表结构
mysqldump -u root -p --no-data campus_card_db > structure_only.sql

# 压缩备份
mysqldump -u root -p campus_card_db | gzip > backup.sql.gz
```

#### MySQL恢复
```bash
# 恢复数据库
mysql -u root -p campus_card_db < backup_20240222.sql

# 恢复压缩备份
gunzip < backup.sql.gz | mysql -u root -p campus_card_db
```

#### 自动备份脚本
```bash
#!/bin/bash
# 数据库备份脚本

DB_USER="root"
DB_PASS="password"
DB_NAME="campus_card_db"
BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
mysqldump -u$DB_USER -p$DB_PASS $DB_NAME > $BACKUP_DIR/${DB_NAME}_${DATE}.sql

# 压缩备份文件
gzip $BACKUP_DIR/${DB_NAME}_${DATE}.sql

# 删除7天前的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete

echo "Backup completed: ${DB_NAME}_${DATE}.sql.gz"
```

### 3.3 性能优化

#### 慢查询分析
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;

-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';

-- 分析查询执行计划
EXPLAIN SELECT * FROM transactions 
WHERE card_id = 'C001' AND transaction_time > '2024-01-01';
```

#### EXPLAIN结果解读
- **type**：访问类型（ALL < index < range < ref < eq_ref < const）
- **key**：实际使用的索引
- **rows**：扫描的行数
- **Extra**：额外信息（Using filesort、Using temporary需要优化）

#### 优化示例
```sql
-- 优化前（全表扫描）
SELECT * FROM transactions WHERE YEAR(transaction_time) = 2024;

-- 优化后（使用索引）
SELECT * FROM transactions 
WHERE transaction_time >= '2024-01-01' AND transaction_time < '2025-01-01';

-- 避免SELECT *
SELECT card_id, amount, transaction_time FROM transactions;

-- 使用LIMIT限制结果集
SELECT * FROM transactions ORDER BY transaction_time DESC LIMIT 100;
```

### 3.4 数据库监控

```sql
-- 查看数据库连接数
SHOW PROCESSLIST;

-- 查看表状态
SHOW TABLE STATUS FROM campus_card_db;

-- 查看索引使用情况
SHOW INDEX FROM transactions;

-- 查看数据库大小
SELECT 
    table_schema AS 'Database',
    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'Size (MB)'
FROM information_schema.tables
GROUP BY table_schema;

-- 查看表大小
SELECT 
    table_name AS 'Table',
    ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size (MB)'
FROM information_schema.tables
WHERE table_schema = 'campus_card_db'
ORDER BY (data_length + index_length) DESC;
```

---

## 四、存储过程与触发器

### 4.1 存储过程

```sql
-- 创建存储过程：校园卡充值
DELIMITER //
CREATE PROCEDURE recharge_card(
    IN p_card_id VARCHAR(20),
    IN p_amount DECIMAL(10,2),
    OUT p_new_balance DECIMAL(10,2)
)
BEGIN
    DECLARE v_current_balance DECIMAL(10,2);
    
    -- 开始事务
    START TRANSACTION;
    
    -- 获取当前余额
    SELECT balance INTO v_current_balance 
    FROM campus_cards 
    WHERE card_id = p_card_id FOR UPDATE;
    
    -- 更新余额
    UPDATE campus_cards 
    SET balance = balance + p_amount 
    WHERE card_id = p_card_id;
    
    -- 记录交易
    INSERT INTO transactions (card_id, amount, transaction_type, transaction_time)
    VALUES (p_card_id, p_amount, 'recharge', NOW());
    
    -- 返回新余额
    SET p_new_balance = v_current_balance + p_amount;
    
    COMMIT;
END //
DELIMITER ;

-- 调用存储过程
CALL recharge_card('C001', 100, @new_balance);
SELECT @new_balance;
```

### 4.2 触发器

```sql
-- 创建触发器：消费后自动更新余额
DELIMITER //
CREATE TRIGGER after_consume_insert
AFTER INSERT ON transactions
FOR EACH ROW
BEGIN
    IF NEW.transaction_type = 'consume' THEN
        UPDATE campus_cards 
        SET balance = balance - NEW.amount 
        WHERE card_id = NEW.card_id;
    END IF;
END //
DELIMITER ;

-- 查看触发器
SHOW TRIGGERS;

-- 删除触发器
DROP TRIGGER IF EXISTS after_consume_insert;
```

---

## 五、常见面试题

### 5.1 理论题

**Q1: 什么是数据库事务？ACID特性是什么？**
答：事务是数据库操作的最小单位，具有ACID特性：
- 原子性：事务中的操作要么全部成功，要么全部失败
- 一致性：事务前后数据保持一致状态
- 隔离性：多个事务并发执行互不干扰
- 持久性：事务提交后数据永久保存

**Q2: 索引的优缺点是什么？**
优点：
- 加快数据检索速度
- 提高排序和分组效率
- 保证数据唯一性

缺点：
- 占用额外存储空间
- 降低INSERT、UPDATE、DELETE速度
- 需要维护成本

**Q3: 内连接和左连接的区别？**
- 内连接（INNER JOIN）：只返回两表匹配的记录
- 左连接（LEFT JOIN）：返回左表所有记录，右表不匹配则为NULL

### 5.2 SQL实战题

**题目：查询每个学院消费总额前3名的学生**
```sql
SELECT department, name, total_amount
FROM (
    SELECT 
        s.department,
        s.name,
        SUM(t.amount) as total_amount,
        ROW_NUMBER() OVER (PARTITION BY s.department ORDER BY SUM(t.amount) DESC) as rn
    FROM students s
    INNER JOIN campus_cards c ON s.student_id = c.student_id
    INNER JOIN transactions t ON c.card_id = t.card_id
    WHERE t.transaction_type = 'consume'
    GROUP BY s.department, s.student_id, s.name
) ranked
WHERE rn <= 3;
```

**题目：查找连续3天都有消费的学生**
```sql
SELECT DISTINCT s.student_id, s.name
FROM students s
INNER JOIN campus_cards c ON s.student_id = c.student_id
INNER JOIN transactions t1 ON c.card_id = t1.card_id
INNER JOIN transactions t2 ON c.card_id = t2.card_id
INNER JOIN transactions t3 ON c.card_id = t3.card_id
WHERE t1.transaction_type = 'consume'
  AND t2.transaction_type = 'consume'
  AND t3.transaction_type = 'consume'
  AND DATE(t2.transaction_time) = DATE_ADD(DATE(t1.transaction_time), INTERVAL 1 DAY)
  AND DATE(t3.transaction_time) = DATE_ADD(DATE(t2.transaction_time), INTERVAL 1 DAY);
```

---

## 六、实践练习

### 练习1：设计校园卡数据库
要求：
1. 设计学生表、校园卡表、商户表、交易表
2. 建立合适的主键和外键关系
3. 创建必要的索引
4. 符合第三范式

### 练习2：编写查询语句
1. 查询本月消费超过500元的学生
2. 统计每个食堂的日均交易额
3. 查找余额不足10元的校园卡
4. 分析每个学院学生的平均消费水平

### 练习3：性能优化
1. 使用EXPLAIN分析慢查询
2. 为高频查询字段添加索引
3. 优化多表关联查询
4. 编写定时清理历史数据的脚本

---

**学习建议**：
1. 每天练习10道SQL题目
2. 搭建MySQL环境进行实操
3. 熟练掌握CRUD操作和多表查询
4. 理解索引原理和事务机制
5. 学会使用EXPLAIN分析查询性能
